# Registry-DTL Prototype

Like `experimental/registry` but uses dependent types.

# Services

We have 3 basic services

1. twicer: multiply an integer by two, return an even number
2. halfer: divide an integer by two, takes an even number
3. incrementer: increment an integer by one

The registry service has 2 procedures

1. retrieve: retrieve a service and procedure matching a given type
   signature.
2. compose: construct a composite service from services of the
   registry given a type signature.  This is useful when the retriever
   fails to retrieve a service for that type signature.

With that we have a composite service to test the registry

1. compo: that calls the registry to retrieve (or compose) a service
   to generate a function of a certain type signature, here Integer ->
   Integer.

# Requirements

- grpc
- grpc-cli
- python-grpcio
- python-grpcio-tools
- idris2

# Usage

1. First time you need to generate boilerplate code for gRPC

```bash
./buildproto.sh
```

2. Start gRPC services

```bash
python3 run_services.py --no-daemon
```

3. Test the various primary services

```bash
python3 test_twicer_service.py
python3 test_halfer_service.py
python3 test_incrementer_service.py
```

4. Test the registry service

```bash
python3 test_registry_service.py
```

Try type signatures such as

```
Integer -> Integer
```

```
Integer -> EvenInteger
```

or even

```
String -> (String, String)
```

the type signature of the registry procedure `retrieve`.

5. Test composite service that uses the registry

```bash
python3 test_compo_service.py
```

By looking at the log generated by `run_services.py` one may see

TODO

```
[2021-04-01 15:52:04,704] [DEBUG] [registry_service] retrieve String -> Double = (Str2Float, str2float)
[2021-04-01 15:52:05,152] [DEBUG] [int2str_service] int2str 42 = "42"
[2021-04-01 15:52:05,563] [DEBUG] [str2float_service] str2float "42" = 42.0
[2021-04-01 15:52:05,564] [DEBUG] [compoint2float_service] compoint2float 42 = 42.0
```

meaning the composite service first calls the registry service to
discover which function could fill the hole, here
`Str2Float.str2float`, then compose it with `Int2Str.int2str` to form
a function

```
Str2Float.str2float . Int2Str.int2str
```

that fulfills its type signature

```
Int -> Double
```

as specified in its idris specification file

```
service/CompoInt2Float.idr
```
