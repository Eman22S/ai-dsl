# Registry-DTL Prototype

Like `experimental/registry` but uses dependent types.

# Services

We have 3 basic services

1. twicer: multiply an integer by two, return an even number
2. halfer: divide an integer by two, takes an even number
3. incrementer: increment an integer by one

The registry service has 2 procedures

1. retrieve: retrieve a service and procedure matching a given type
   signature.
2. compose: construct a composite service from services of the
   registry given a type signature.  This is useful when the retriever
   fails to retrieve a service for that type signature.

With that we have a composite service to test the registry

1. compo: that calls the registry to retrieve (or compose) a service
   to generate a function of a certain type signature, here Integer ->
   Integer.

# Requirements

- grpc
- grpc-cli
- python-grpcio
- python-grpcio-tools
- idris2

# Usage

1. First time you need to generate boilerplate code for gRPC

```bash
./buildproto.sh
```

2. Start gRPC services

```bash
python3 run_services.py --no-daemon
```

3. Test the various primary services

```bash
python3 test_twicer_service.py
python3 test_halfer_service.py
python3 test_incrementer_service.py
```

4. Test the registry service

```bash
python3 test_registry_service.py
```

Try type signatures such as

```
Integer -> EvenInteger
```

or equivalently

```
Integer -> (n : WFInt ** Parity n (Nat 2))
```

using the actual dependent type definition of an even integer instead
of its shorthand `EvenInteger`.

5. Test composite service that uses the registry

```bash
python3 test_compo_service.py
```

By looking at the log generated by `run_services.py` one may see

```
[2021-05-14 09:49:43,696] [DEBUG] [registry_service] retrieve Integer -> EvenInteger = (Twicer, twicer)
[2021-05-14 09:49:44,228] [DEBUG] [twicer_service] twicer 41 = 82
[2021-05-14 09:49:44,818] [DEBUG] [halfer_service] halfer 82 = 41
[2021-05-14 09:49:45,254] [DEBUG] [incrementer_service] incrementer 41 = 42
[2021-05-14 09:49:45,255] [DEBUG] [compo_service] compo 41 = 42
```

meaning the composite service first calls the registry service to
discover which function could fill the hole, here `Twicer.twicer`,
then compose it with the halfer and the incrementer to form the
function

```
incrementer . (halfer . twicer)
```

Of course such composite function is just gonna increment a number,
but the important part is that the registry was able to properly
retrieve the missing function outputing an even integer, ultimately
described as a dependent type `(n : WFInt ** Parity n (Nat 2))` to
match the input of `halfer`.
